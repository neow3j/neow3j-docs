# Preliminaries

The following sections introduce general concepts and types that you will encounter within the neow3j SDK.

## Hashes

Hashes are frequently used in the blockchain world, and Neo is no exception. There are two types of hashes in Neo. One is 256 bits long and is generated by applying the SHA-256 algorithm (a member of the SHA-2 cryptographic hash functions) twice to certain input data. This type of hash is used for transaction and block hashes. The other type is 160 bits long and is generated by first applying SHA-256 and then RIPEMD-160 to specific input data. This hash type is used for identifying accounts and contracts in the form of script hashes, which are hashes of the scripts associated with those accounts and contracts.

The neow3j SDK uses the types `io.neow3j.contract.Hash256` and `io.neow3j.contract.Hash160` for these two types of hashes, respectively. You will find that the SDK's API typically requires you to work with these specific types rather than a simple string or byte array. It's important to note that the hashes stored by these types are stored in big-endian order, but they can be retrieved in little-endian order using the `toLittleEndianArray()` method. Endianness can be a concern when inspecting results from contract invocations because the Neo node might return a hash in little-endian order. This difference in endianness must be taken into account when constructing a `Hash160` or `Hash256` object.

## NeoVM Stack Items

The NeoVM is the virtual machine responsible for executing all smart contract code on the Neo blockchain. When a contract is invoked on the Neo blockchain, the result of that invocation is a list of items that remain on the NeoVM's stack at the end of the invocation. These items are referred to as stack items and are represented by the `StackItem` class in the neow3j SDK. Stack items can belong to several predefined types that exist within the NeoVM, and they need to be mapped to Java types when received by the SDK from a Neo node. This mapping isn't a straightforward one-to-one translation but allows room for interpretation. For instance, an integer stack item can be interpreted as a boolean value if it falls within the range of 0 and 1. Similarly, a byte array can be interpreted as an integer value.

The `StackItem` class in neow3j allows you to specify the Java type to which you want to convert a stack item. Any stack item returned by a Neo node will be encapsulated within the `StackItem` class. If you are expecting a boolean value from an invocation, you can use `stackItem.getBoolean()` to retrieve `true` or `false`, even if the underlying stack item is an integer with a value of 0 or 1. However, if the stack item cannot be cast to the desired type, an exception will be thrown. For example, calling `stackItem.getMap()` on an integer stack item will not interpret the integer as a map; instead, it will throw an exception. Therefore, it's important to know beforehand what type of stack item an invocation will return to handle it appropriately in your code.
